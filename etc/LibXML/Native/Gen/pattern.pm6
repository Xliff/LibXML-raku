use v6;
#  -- DO NOT EDIT --
# generated by: etc/generator.p6 

unit module LibXML::Native::Gen::pattern;
# pattern expression handling:
#    allows to compile and test pattern expressions for nodes either in a tree or based on a parser state. 
use LibXML::Native::Defs :LIB, :XmlCharP;

enum xmlPatternFlags is export {
    XML_PATTERN_DEFAULT => 0,
    XML_PATTERN_XPATH => 1,
    XML_PATTERN_XSFIELD => 4,
    XML_PATTERN_XSSEL => 2,
}

struct xmlPattern is repr('CPointer') {
}

struct xmlStreamCtxt is repr('CPointer') {
}

sub xmlFreePattern(xmlPatternPtr $comp) is native(LIB) {*};
sub xmlFreePatternList(xmlPatternPtr $comp) is native(LIB) {*};
sub xmlFreeStreamCtxt(xmlStreamCtxtPtr $stream) is native(LIB) {*};
sub xmlPatternFromRoot(xmlPatternPtr $comp --> int32) is native(LIB) {*};
sub xmlPatternGetStreamCtxt(xmlPatternPtr $comp --> xmlStreamCtxtPtr) is native(LIB) {*};
sub xmlPatternMatch(xmlPatternPtr $comp, xmlNodePtr $node --> int32) is native(LIB) {*};
sub xmlPatternMaxDepth(xmlPatternPtr $comp --> int32) is native(LIB) {*};
sub xmlPatternMinDepth(xmlPatternPtr $comp --> int32) is native(LIB) {*};
sub xmlPatternStreamable(xmlPatternPtr $comp --> int32) is native(LIB) {*};
sub xmlPatterncompile(xmlCharP $pattern, xmlDict * $dict, int32 $flags, const xmlChar ** $namespaces --> xmlPatternPtr) is native(LIB) {*};
sub xmlStreamPop(xmlStreamCtxtPtr $stream --> int32) is native(LIB) {*};
sub xmlStreamPush(xmlStreamCtxtPtr $stream, xmlCharP $name, xmlCharP $ns --> int32) is native(LIB) {*};
sub xmlStreamPushAttr(xmlStreamCtxtPtr $stream, xmlCharP $name, xmlCharP $ns --> int32) is native(LIB) {*};
sub xmlStreamPushNode(xmlStreamCtxtPtr $stream, xmlCharP $name, xmlCharP $ns, int32 $nodeType --> int32) is native(LIB) {*};
sub xmlStreamWantsAnyNode(xmlStreamCtxtPtr $streamCtxt --> int32) is native(LIB) {*};
