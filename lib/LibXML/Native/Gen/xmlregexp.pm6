use v6;
#  -- DO NOT EDIT --
# generated by: etc/generator.p6 

unit module LibXML::Native::Gen::xmlregexp;
# regular expressions handling:
#    basic API for libxml regular expressions handling used for XML Schemas and validation. 
use LibXML::Native::Defs :LIB, :XmlCharP;

enum xmlExpNodeType is export {
    XML_EXP_ATOM => 2,
    XML_EXP_COUNT => 5,
    XML_EXP_EMPTY => 0,
    XML_EXP_FORBID => 1,
    XML_EXP_OR => 4,
    XML_EXP_SEQ => 3,
}

struct xmlExpCtxt is repr('CPointer') {
    sub xmlExpNewCtxt(int32 $maxNodes, xmlDict $dict --> xmlExpCtxt) is native(LIB) {*};
    method xmlExpCtxtNbCons( --> int32) is native(LIB) {*};
    method xmlExpCtxtNbNodes( --> int32) is native(LIB) {*};
    method xmlExpExpDerive(xmlExpNode $exp, xmlExpNode $sub --> xmlExpNode) is native(LIB) {*};
    method xmlExpFree(xmlExpNode $exp --> void) is native(LIB) {*};
    method xmlExpFreeCtxt( --> void) is native(LIB) {*};
    method xmlExpGetLanguage(xmlExpNode $exp, const xmlChar ** $langList, int32 $len --> int32) is native(LIB) {*};
    method xmlExpGetStart(xmlExpNode $exp, const xmlChar ** $tokList, int32 $len --> int32) is native(LIB) {*};
    method xmlExpNewAtom(xmlCharP $name, int32 $len --> xmlExpNode) is native(LIB) {*};
    method xmlExpNewOr(xmlExpNode $left, xmlExpNode $right --> xmlExpNode) is native(LIB) {*};
    method xmlExpNewRange(xmlExpNode $subset, int32 $min, int32 $max --> xmlExpNode) is native(LIB) {*};
    method xmlExpNewSeq(xmlExpNode $left, xmlExpNode $right --> xmlExpNode) is native(LIB) {*};
    method xmlExpParse(Str $expr --> xmlExpNode) is native(LIB) {*};
    method xmlExpStringDerive(xmlExpNode $exp, xmlCharP $str, int32 $len --> xmlExpNode) is native(LIB) {*};
    method xmlExpSubsume(xmlExpNode $exp, xmlExpNode $sub --> int32) is native(LIB) {*};
}

struct xmlExpNode is repr('CPointer') {
    method xmlExpIsNillable( --> int32) is native(LIB) {*};
    method xmlExpMaxToken( --> int32) is native(LIB) {*};
    method xmlExpRef( --> void) is native(LIB) {*};
}

struct xmlRegExecCtxt is repr('CPointer') {
    method xmlRegExecErrInfo(const xmlChar ** $string, int * $nbval, int * $nbneg, xmlChar ** $values, int * $terminal --> int32) is native(LIB) {*};
    method xmlRegExecNextValues(int * $nbval, int * $nbneg, xmlChar ** $values, int * $terminal --> int32) is native(LIB) {*};
    method xmlRegExecPushString(xmlCharP $value, Pointer $data --> int32) is native(LIB) {*};
    method xmlRegExecPushString2(xmlCharP $value, xmlCharP $value2, Pointer $data --> int32) is native(LIB) {*};
    method xmlRegFreeExecCtxt( --> void) is native(LIB) {*};
}

struct xmlRegexp is repr('CPointer') {
    sub xmlRegexpCompile(xmlCharP $regexp --> xmlRegexp) is native(LIB) {*};
    method xmlRegFreeRegexp( --> void) is native(LIB) {*};
    method xmlRegNewExecCtxt(xmlRegExecCallbacks $callback, Pointer $data --> xmlRegExecCtxt) is native(LIB) {*};
    method xmlRegexpExec(xmlCharP $content --> int32) is native(LIB) {*};
    method xmlRegexpIsDeterminist( --> int32) is native(LIB) {*};
}
    sub xmlRegexpPrint(FILE * $output, xmlRegexp $regexp --> void) is native(LIB) {*};
